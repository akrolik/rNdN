#pragma once

#include "PTX/Tree/Node.h"

#include <string>
#include <sstream>
#include <vector>
#include <unordered_map>

#include "PTX/Tree/Declarations/Declaration.h"
#include "PTX/Tree/Directives/Directive.h"
#include "PTX/Tree/Functions/Function.h"
#include "PTX/Tree/Type.h"

namespace PTX {

class Module : public Node
{
public:
	void SetVersion(unsigned int major, unsigned int minor) { m_versionMajor = major; m_versionMinor = minor; }
	void SetDeviceTarget(const std::string& target) { m_target = target; }
	void SetAddressSize(Bits addressSize) { m_addressSize = addressSize; }

	void AddEntryFunction(const Function *function)
	{
		m_entryFunctions.insert({function->GetName(), function});
	}
	bool ContainsEntryFunction(const std::string& name) const
	{
		return m_entryFunctions.find(name) != m_entryFunctions.end();
	}
	const Function *GetEntryFunction(const std::string& name) const
	{
		return m_entryFunctions.at(name);
	}
	const std::unordered_map<std::string, const Function *>& GetEntryFunctions() const
	{
		return m_entryFunctions;
	}

	void AddDirective(const Directive *directive)
	{
		m_directives.push_back(directive);
	}
	template<class T>
	void AddDirectives(const std::vector<T>& directives)
	{
		m_directives.insert(std::end(m_directives), std::begin(directives), std::end(directives));
	}

	void AddDeclaration(const Declaration *declaration)
	{
		m_declarations.push_back(declaration);
	}
	template<class T>
	void AddDeclarations(const std::vector<T>& declarations)
	{
		m_declarations.insert(std::end(m_declarations), std::begin(declarations), std::end(declarations));
	}

	void InsertDeclaration(const Declaration *declaration, unsigned int index)
	{
		m_declarations.insert(std::begin(m_declarations) + index, declaration);
	}
	template<class T>
	void InsertDeclarations(const std::vector<T>& declarations, unsigned int index)
	{
		m_declarations.insert(std::begin(m_declarations) + index, std::begin(declarations), std::end(declarations));
	}

	std::string ToString(unsigned int indentation) const override
	{
		std::string code =
			"//\n"
			"// Generated by r3r3 compiler\n"
			"// version 0.1\n"
			"//\n\n"
		;

		code += ".version " + std::to_string(m_versionMajor) + "." + std::to_string(m_versionMinor) + "\n";
		code += ".target " + m_target + "\n";
		code += ".address_size " + std::to_string(DynamicBitSize::GetBits(m_addressSize)) + "\n";

		for (const auto& directive : m_directives)
		{
			code += directive->ToString(0) + "\n";
		}
		code += "\n";

		bool first = true;
		for (const auto& declaration : m_declarations)
		{
			if (!first)
			{
				code += "\n\n";
			}
			first = false;
			code += declaration->ToString(0);
		}

		return code;
	}

	json ToJSON() const override
	{
		json j;
		j["version_major"] = m_versionMajor;
		j["version_minor"] = m_versionMinor;
		j["target"] = m_target;
		j["address_size"] = DynamicBitSize::GetBits(m_addressSize);
		for (const auto& directive : m_directives)
		{
			j["directive"].push_back(directive->ToJSON());
		}
		for (const auto& declaration : m_declarations)
		{
			j["declarations"].push_back(declaration->ToJSON());
		}
		return j;
	}

	// Visitors

	void Accept(ConstHierarchicalVisitor& visitor) const override
	{
		if (visitor.VisitIn(this))
		{
			for (const auto& directive : m_directives)
			{
				directive->Accept(visitor);
			}
			for (const auto& declaration : m_declarations)
			{
				declaration->Accept(visitor);
			}
		}
		visitor.VisitOut(this);
	}


private:
	unsigned int m_versionMajor, m_versionMinor;
	std::string m_target;
	Bits m_addressSize = Bits::Bits32;

	std::vector<const Directive *> m_directives;
	std::vector<const Declaration *> m_declarations;

	std::unordered_map<std::string, const Function *> m_entryFunctions;
};

}
